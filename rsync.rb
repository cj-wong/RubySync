#!/usr/bin/env ruby
require "yaml"


# If necessary, join root and relative for a full path. Additionally,
# replace instances of 'USER' or 'DEVICE' with appropriate values.
#
# @param root [String, nil] The root directory defined in config.yaml.
# @param relative [String, nil] A relative path under root. If `nil`, the
#   relative path doesn't exist.
# @param what [String] The target to replace; either 'USER' or 'DEVICE'.
# @param replace [String] The replacement string; replaces instances of `what`
#   in `path`.
# @return [String] An updated string with replacements (`what` -> `replace`)
#   and `root` joined to `relative` if necessary.
def update_path(root, relative, what, replace)
    # Be careful - either the end of root or beginning of relative should
    # have a slash, preferably at the tail of root.
    if root.nil? and relative.nil?
        raise ArgumentError, "Both root and relative are empty"
    end
    unless what == 'USER' or what == 'DEVICE'
        raise ArgumentError, "Invalid replacement; must be USER or DEVICE"
    end

    if root.nil?
        path = relative
    elsif relative.nil?
        path = root
    else
        path = root + relative
    end

    return path unless path.include? what
    path[what] = replace
    return path
end

# Get the partial command (common args) for rsync determined by `direction`.
#
# @param direction [String] The direction of sync; either 'backup' or 'restore'
# @param args [Array] An array of arguments to be supplied to rsync.
# @return [String] The partial command determined by `direction`.
def get_partial_cmd(direction, args)
    arg = ''
    n = direction == 'backup' ? 1 : 2
    unless args[0]['common'].nil? or args[0]['common'].empty?
       arg << args[0]['common'][0]
    end
    unless args[n][direction].nil? or args[n][direction].empty?
       arg << args[n][direction][0]
    end

    return "rsync #{arg} "
end

# Synchronize from a source to a destination.
#
# @param direction [String] The direction of sync; either 'backup' or 'restore'
# @param source [String] The source; syncs to `dest`, but if `direction` is
#   'restore', `source` becomes `dest`, and `dest` becomes `source`.
# @param dest [String] The destination; see note for `source`. In addition,
#   `dest` can be a comma-delimited string for batch processing.
# @param cmd [String] The partial command generated by `get_partial_cmd`.
# @param files [Array, nil] An optional array of files by path. If defined,
#   rsync recursive is disabled. Files must be relative to the `source` path.
#   Only those files will be synchronized.
# @return [true, false, nil] If the command exists, command success is true and
#   command failure is false; if the command doesn't exist, nil
def sync(direction, local, target, cmd, files = nil)
    if direction == 'backup'
        source, dest = local, target
    else
        source, dest = target, local
    end

    command = cmd.dup

    if files.nil?
        command << "-R #{source} "
    else
        files.each { |file| file.prepend(source) }
        files = files.join(' ')
        command << "#{files} "
    end

    command << "#{dest} | grep -vi 'skipping non-regular file'"

    puts "Source:\n    #{source}\n\n"
    puts "Destination:\n    #{dest}\n\n"
    puts "Sync command:\n    #{command}\n\n"
    puts "Syncing..."

    return system(command)
end

# Start of the script.
def main()
    config = YAML.load_file('config.yaml')

    # If the optional device name is missing, use the hostname instead.
    if config['device'].to_s.empty?
        require "socket"
        config['device'] = Socket.gethostname
    end

    # Sanitize args.
    unless ARGV[0] == 'backup' or ARGV[0] == 'restore'
        abort("Invalid argument: #{ARGV[0]} should be 'backup' or 'restore'")
    end

    # Get paths from config, and if necessary, manipulate them.
    root = config['paths']['root']

    cmd = get_partial_cmd(ARGV[0], config['args'])

    ARGV[1].split(',').each { |target|
        begin
            # Check whether `target` is a valid target in the config.
            target = config['paths'][target]
            if target.nil?
                raise ArgumentError, "#{target} is not a valid target"
            end

            path_local = update_path(
                root['local'],
                target['local'],
                'USER',
                ENV['USER'],
            )
            path_target = update_path(
                root['remote'],
                target['remote'],
                'DEVICE',
                config['device'],
            )

            # Does the config list files? Use those instead if so.
            if target['files'].nil?
                files = nil
            else
                files = target['files'].split(',')
            end

            # Finally, sync using all the args.
            sync(ARGV[0], path_local, path_target, cmd, files=files)
        rescue ArgumentError => ex
            puts ex
            puts "Ignoring and continuing..."
        end
    }
end

main()
